C251 COMPILER V5.60.0,  straight                                                           26/11/24  18:20:41  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE straight
OBJECT MODULE PLACED IN .\Out_File\straight.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\CODE\Algorithms\straight.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEED)
                    - BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;
                    -..\USER\inc;..\USER\src;..\..\Libraries\seekfree_components;..\CODE\UserLibraries;..\CODE\Algorithms) DEBUG PRINT(.\Out_
                    -File\straight.lst) TABS(2) OBJECT(.\Out_File\straight.obj) 

stmt  level    source

    1          /*********************
    2           * straight.c
    3           * 
    4           * 作者: COTOMO
    5           * 项目地址: https://github.com/Eclipse-01/SmartVehicleSchool
    6           * MIT开源证书
    7           * JNU-FLY at Jiangnan University
    8           * 2024 November
    9           * 
   10           * 本文件实现了小车直行的PID控制算法和异常处理逻辑。
   11           ********************************************************************************************************
             -************/
   12          
   13          #include "headfile.h"
   14          #include "straight.h"
   15          
   16          #define XINGS 1 // 定义十字的数量
   17          #define VELOCITY 40
   18          
   19          #define USE_DYNAMIC_SPEED 
   20          
   21          #ifdef USE_DYNAMIC_SPEED
   22          #define MOTOR_SPEED dynamic_speed()
   23          #else
               #define MOTOR_SPEED VELOCITY
               #endif // USE_DYNAMIC_SPEED
   26          int recv = 32;
   27          char str[64];
   28          int dynamic_speed();
   29          /*PID参数调节器*/
   30          float Kp = 0.595;
   31          float Ki = 0.00000;
   32          float Kd = 3.145;
   33          float reactFactor = 1;
   34          
   35          // 添加积分和微分的最大值变量
   36          float MAX_INTEGRAL = 100.0;    // 根据需要调整
   37          float MAX_DERIVATIVE = 1000.0; // 根据需要调整
   38          
   39          /**
   40           * @brief 直行入口函数
   41           * @return uint8 返回值
   42           */
   43          uint8 straight_entrance(void)
   44          {
   45   1          ips200_clear();
   46   1          ips200_show_string(0, 0, "Straight mode");
   47   1          wireless_uart_send_buff("Straight mode\n", 13);
   48   1          while (1)
   49   1          {
   50   2              Remote_Stop();
   51   2              PID_control_straint();
   52   2              delay_ms(10);
   53   2          }
   54   1          return 0;
   55   1      }
C251 COMPILER V5.60.0,  straight                                                           26/11/24  18:20:41  PAGE 2   

   56          
   57          /**
   58           * @brief PID控制函数
   59           */
   60          
   61          int position;
   62          static int last_error = 0;
   63          static int integral = 0;
   64          int angle;
   65          
   66          void PID_control_straint(void)
   67          {
   68   1      
   69   1          position = Line_calculate_position();
   70   1          integral += position;
   71   1          angle = (position * Kp + integral * Ki + (position - last_error) * Kd) * reactFactor;
   72   1          last_error = position;
   73   1          servo_set_position(angle);
   74   1          drv8701_control(MOTOR_BOTH, MOTOR_SPEED);
   75   1      
   76   1          if (integral > MAX_INTEGRAL)
   77   1              integral = MAX_INTEGRAL;
   78   1          if (integral < -MAX_INTEGRAL)
   79   1              integral = -MAX_INTEGRAL;
   80   1          // if (last_error > MAX_DERIVATIVE)
   81   1          //     last_error = MAX_DERIVATIVE;
   82   1          // if (last_error < -MAX_DERIVATIVE)
   83   1          //     last_error = -MAX_DERIVATIVE;
   84   1      }
   85          
   86          void PID_control_ring(void)
   87          {
   88   1      
   89   1          position = Line_calculate_position_ring();
   90   1          integral += position;
   91   1          angle = (position * Kp + integral * Ki + (position - last_error) * Kd) * reactFactor;
   92   1          last_error = position;
   93   1          servo_set_position(angle);
   94   1          drv8701_control(MOTOR_BOTH,25);
   95   1      
   96   1          if (integral > MAX_INTEGRAL)
   97   1              integral = MAX_INTEGRAL;
   98   1          if (integral < -MAX_INTEGRAL)
   99   1              integral = -MAX_INTEGRAL;
  100   1          // if (last_error > MAX_DERIVATIVE)
  101   1          //     last_error = MAX_DERIVATIVE;
  102   1          // if (last_error < -MAX_DERIVATIVE)
  103   1          //     last_error = -MAX_DERIVATIVE;
  104   1      }
  105          
  106          static float last_speed = 0;
  107          /**
  108           * @brief 动态速度控制函数
  109           * @return int 返回速度
  110           */
  111          int dynamic_speed()
  112          {
  113   1          float this_speed;
  114   1          this_speed = VELOCITY - abs(servo_position) * 0.2 - abs(position) * 0.07;
  115   1          if (this_speed - last_speed > 0.7)
  116   1              this_speed = last_speed + 0.7;
  117   1          if (this_speed < 30)
  118   1              this_speed = 30;
  119   1          last_speed = this_speed;
  120   1          return this_speed;
  121   1      }
C251 COMPILER V5.60.0,  straight                                                           26/11/24  18:20:41  PAGE 3   

  122          
  123          /**
  124           * @brief 异常处理函数
  125           * @param exception_code 异常代码
  126           */
  127          void exception_handler(int exception_code)
  128          {
  129   1          ips200_clear();
  130   1          ips200_show_string(0, 0, "Exception occured");
  131   1          switch (exception_code)
  132   1          {
  133   2          case 999:
  134   2              ips200_show_string(16, 0, "System error");
  135   2              break;
  136   2          case 998:
  137   2              ips200_show_string(16, 0, "Divide by zero");
  138   2              break;
  139   2          case 997:
  140   2              ips200_show_string(16, 0, "Line lost");
  141   2              break;
  142   2          case 996:
  143   2              ips200_show_string(16, 0, "Cross line");
  144   2              return;
  145   2          case 995:
  146   2              ips200_show_string(16, 0, "Left roundabout");
  147   2              break;
  148   2          case 994:
  149   2              ips200_show_string(16, 0, "Right roundabout");
  150   2              break;
  151   2          default:
  152   2              ips200_show_string(16, 0, "Unknown error");
  153   2          }
  154   1      }
  155          
  156          /**
  157           * @brief 计算线的位置
  158           *
  159           * 根据滤波后的ADC值计算线的位置，还能检测环岛
  160           *
  161           * @return int 线的位置
  162           * @warning 小心使用
  163           */
  164          
  165          extern uint8 RING_FLAG = 0; // 声明外部变量
  166          int Line_calculate_position()
  167          {
  168   1          float adc1, adc2, adc3, adc4, denominator, position;
  169   1          Line_read_raw();
  170   1      
  171   1          // 归一化处理，范围是0-100
  172   1          adc1 = ((float)adc_value.ADC1 * 100) / 4095;
  173   1          adc2 = ((float)adc_value.ADC2 * 100) / 4095;
  174   1          adc3 = ((float)adc_value.ADC3 * 100) / 4095;
  175   1          adc4 = ((float)adc_value.ADC4 * 100) / 4095;
  176   1      
  177   1          if ((adc1 + adc4 > 160)) // 检测到环岛
  178   1          {
  179   2              RING_FLAG = RING_FLAG ^ 1;
  180   2              if (RING_FLAG == 1){
  181   3              Beep_set(1);
  182   3              last_speed = 30;
  183   3              ring_handler();}
  184   2          }
  185   1          denominator = adc1 + adc4;
  186   1          if (denominator == 0)
  187   1              denominator = 1;
C251 COMPILER V5.60.0,  straight                                                           26/11/24  18:20:41  PAGE 4   

  188   1          position = (adc4 - adc1) / denominator * 100;
  189   1          sprintf(str, "Position: %f, adc1: %f, adc4: %f\n", position, adc1, adc4);
  190   1          wireless_uart_send_buff(str, strlen(str));
  191   1          return position;
  192   1      }
  193          
  194          /**
  195           * @brief 计算线的位置
  196           *
  197           * 根据滤波后的ADC值计算线的位置，在环岛内使用
  198           *
  199           * @return int 线的位置
  200           * @warning 小心使用
  201           */
  202          
  203          extern uint8 RING_FLAG; // 声明外部变量
  204          int Line_calculate_position_ring()
  205          {
  206   1          float adc1, adc2, adc3, adc4, denominator, position;
  207   1          Line_read_raw();
  208   1      
  209   1          // 归一化处理，范围是0-100
  210   1          adc1 = ((float)adc_value.ADC1 * 100) / 4095;
  211   1          adc2 = ((float)adc_value.ADC2 * 100) / 4095;
  212   1          adc3 = ((float)adc_value.ADC3 * 100) / 4095;
  213   1          adc4 = ((float)adc_value.ADC4 * 100) / 4095;
  214   1          denominator = adc1 + adc4;
  215   1          if (denominator == 0)
  216   1              denominator = 1;
  217   1          position = (adc4 - adc1) / denominator * 100;
  218   1          sprintf(str, "Position: %f\n, adc1: %f, adc4: %f\n", position, adc1, adc4);
  219   1          wireless_uart_send_buff(str, strlen(str));
  220   1          return position;
  221   1      }
  222          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1360     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       157     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       291     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
