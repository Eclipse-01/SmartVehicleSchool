C251 COMPILER V5.60.0,  straight                                                           21/11/24  16:32:52  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE straight
OBJECT MODULE PLACED IN .\Out_File\straight.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\CODE\Algorithms\straight.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEED)
                    - BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;
                    -..\USER\inc;..\USER\src;..\..\Libraries\seekfree_components;..\CODE\UserLibraries;..\CODE\Algorithms) DEBUG PRINT(.\Out_
                    -File\straight.lst) TABS(2) OBJECT(.\Out_File\straight.obj) 

stmt  level    source

    1          /*********************
    2           * straight.c
    3           * 
    4           * 作者: COTOMO
    5           * 项目地址: https://github.com/Eclipse-01/SmartVehicleSchool
    6           * MIT开源证书
    7           * JNU-FLY at Jiangnan University
    8           * 2024 November
    9           * 
   10           * 本文件实现了小车直行的PID控制算法和异常处理逻辑。
   11           ********************************************************************************************************
             -************/
   12          
   13          #include "headfile.h"
   14          #include "straight.h"
   15          
   16          #define XINGS 1 // 定义十字的数量
   17          #define VELOCITY 40
   18          int recv = 32;
   19          char str[64];
   20          /*PID参数调节器*/
   21          float Kp = 0.5;
   22          float Ki = 0;
   23          float Kd = 0.35;
   24          float reactFactor = 1;
   25          
   26          // 添加积分和微分的最大值变量
   27          float MAX_INTEGRAL = 100.0;    // 根据需要调整
   28          float MAX_DERIVATIVE = 1000.0; // 根据需要调整
   29          
   30          /**
   31           * @brief 直行入口函数
   32           * @return uint8 返回值
   33           */
   34          uint8 straight_entrance(void)
   35          {
   36   1          ips200_clear();
   37   1          ips200_show_string(0, 0, "Straight mode");
   38   1          wireless_uart_send_buff("Straight mode\n", 13);
   39   1          while (1)
   40   1          {
   41   2              Remote_Stop();
   42   2              PID_control_straint();
   43   2              delay_ms(10);
   44   2          }
   45   1          return 0;
   46   1      }
   47          
   48          /**
   49           * @brief PID控制函数
   50           */
   51          
   52          int position;
   53          static int last_error = 0;
   54          static int integral = 0;
   55          int angle;
C251 COMPILER V5.60.0,  straight                                                           21/11/24  16:32:52  PAGE 2   

   56          
   57          void PID_control_straint(void)
   58          {
   59   1      
   60   1          position = Line_calculate_position();
   61   1          integral += position;
   62   1          angle = (position * Kp + integral * Ki + (position - last_error) * Kd) * reactFactor;
   63   1          last_error = position;
   64   1          servo_set_position(angle);
   65   1          drv8701_control(MOTOR_BOTH, VELOCITY);
   66   1      
   67   1          if (integral > MAX_INTEGRAL)
   68   1              integral = MAX_INTEGRAL;
   69   1          if (integral < -MAX_INTEGRAL)
   70   1              integral = -MAX_INTEGRAL;
   71   1          if (last_error > MAX_DERIVATIVE)
   72   1              last_error = MAX_DERIVATIVE;
   73   1          if (last_error < -MAX_DERIVATIVE)
   74   1              last_error = -MAX_DERIVATIVE;
   75   1      }
   76          
   77          void PID_control_ring(void)
   78          {
   79   1      
   80   1          position = Line_calculate_position_ring();
   81   1          integral += position;
   82   1          angle = (position * Kp + integral * Ki + (position - last_error) * Kd) * reactFactor;
   83   1          last_error = position;
   84   1          servo_set_position(angle);
   85   1          drv8701_control(MOTOR_BOTH, VELOCITY);
   86   1      
   87   1          if (integral > MAX_INTEGRAL)
   88   1              integral = MAX_INTEGRAL;
   89   1          if (integral < -MAX_INTEGRAL)
   90   1              integral = -MAX_INTEGRAL;
   91   1          if (last_error > MAX_DERIVATIVE)
   92   1              last_error = MAX_DERIVATIVE;
   93   1          if (last_error < -MAX_DERIVATIVE)
   94   1              last_error = -MAX_DERIVATIVE;
   95   1      }
   96          
   97          /**
   98           * @brief 异常处理函数
   99           * @param exception_code 异常代码
  100           */
  101          void exception_handler(int exception_code)
  102          {
  103   1          ips200_clear();
  104   1          ips200_show_string(0, 0, "Exception occured");
  105   1          switch (exception_code)
  106   1          {
  107   2          case 999:
  108   2              ips200_show_string(16, 0, "System error");
  109   2              break;
  110   2          case 998:
  111   2              ips200_show_string(16, 0, "Divide by zero");
  112   2              break;
  113   2          case 997:
  114   2              ips200_show_string(16, 0, "Line lost");
  115   2              break;
  116   2          case 996:
  117   2              ips200_show_string(16, 0, "Cross line");
  118   2              return;
  119   2          case 995:
  120   2              ips200_show_string(16, 0, "Left roundabout");
  121   2              break;
C251 COMPILER V5.60.0,  straight                                                           21/11/24  16:32:52  PAGE 3   

  122   2          case 994:
  123   2              ips200_show_string(16, 0, "Right roundabout");
  124   2              break;
  125   2          default:
  126   2              ips200_show_string(16, 0, "Unknown error");
  127   2          }
  128   1      }
  129          
  130          /**
  131           * @brief 计算线的位置
  132           *
  133           * 根据滤波后的ADC值计算线的位置，还能检测环岛
  134           *
  135           * @return int 线的位置
  136           * @warning 小心使用
  137           */
  138          
  139          extern uint8 RING_FLAG; // 声明外部变量
  140          int Line_calculate_position()
  141          {
  142   1          float adc1, adc2, adc3, adc4, denominator, position;
  143   1          Line_read_raw();
  144   1      
  145   1          // 归一化处理，范围是0-100
  146   1          adc1 = ((float)adc_value.ADC1 * 100) / 4095;
  147   1          adc2 = ((float)adc_value.ADC2 * 100) / 4095;
  148   1          adc3 = ((float)adc_value.ADC3 * 100) / 4095;
  149   1          adc4 = ((float)adc_value.ADC4 * 100) / 4095;
  150   1      
  151   1          if ((adc1 + adc4 > 160) && RING_FLAG == 0) // 检测到环岛
  152   1          {
  153   2              Beep_set(1);
  154   2              ring_handler();
  155   2          }
  156   1          denominator = adc1 + adc4;
  157   1          if (denominator == 0)
  158   1              denominator = 1;
  159   1          position = (adc4 - adc1) / denominator * 100;
  160   1          sprintf(str, "Position: %f, adc1: %f, adc4: %f\n", position, adc1, adc4);
  161   1          wireless_uart_send_buff(str, strlen(str));
  162   1          return position;
  163   1      }
  164          
  165          /**
  166           * @brief 计算线的位置
  167           *
  168           * 根据滤波后的ADC值计算线的位置，在环岛内使用
  169           *
  170           * @return int 线的位置
  171           * @warning 小心使用
  172           */
  173          
  174          extern uint8 RING_FLAG; // 声明外部变量
  175          int Line_calculate_position_ring()
  176          {
  177   1          float adc1, adc2, adc3, adc4, denominator, position;
  178   1          Line_read_raw();
  179   1      
  180   1          // 归一化处理，范围是0-100
  181   1          adc1 = ((float)adc_value.ADC1 * 100) / 4095;
  182   1          adc2 = ((float)adc_value.ADC2 * 100) / 4095;
  183   1          adc3 = ((float)adc_value.ADC3 * 100) / 4095;
  184   1          adc4 = ((float)adc_value.ADC4 * 100) / 4095;
  185   1          denominator = adc1 + adc4;
  186   1          if (denominator == 0)
  187   1              denominator = 1;
C251 COMPILER V5.60.0,  straight                                                           21/11/24  16:32:52  PAGE 4   

  188   1          position = (adc4 - adc1) / denominator * 100;
  189   1          sprintf(str, "Position: %f\n, adc1: %f, adc4: %f\n", position, adc1, adc4);
  190   1          wireless_uart_send_buff(str, strlen(str));
  191   1          return position;
  192   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1301     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       148     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       278     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
