C251 COMPILER V5.60.0,  straight                                                           14/11/24  19:52:40  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE straight
OBJECT MODULE PLACED IN .\Out_File\straight.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\CODE\Algorithms\straight.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEED)
                    - BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;
                    -..\USER\inc;..\USER\src;..\..\Libraries\seekfree_components;..\CODE\UserLibraries;..\CODE\Algorithms) DEBUG PRINT(.\Out_
                    -File\straight.lst) TABS(2) OBJECT(.\Out_File\straight.obj) 

stmt  level    source

    1          /*
    2          *此代码可以使小车沿着直线前进
    3          *By JNU-Fly
    4          */
    5          
    6          #include "headfile.h"
    7          #include "straight.h"
    8          
    9          /*PID参数调节器*/
   10          float Kp = 0.05;
   11          float Ki = 0;
   12          float Kd = 0.05;
   13          float reactFactor = 1; 
   14          
   15          // 添加积分和微分的最大值变量
   16          float MAX_INTEGRAL = 100.0;   // 根据需要调整
   17          float MAX_DERIVATIVE = 1000.0; // 根据需要调整
   18          
   19          /**
   20           * @brief 直行入口函数
   21           * @return uint8 返回值
   22           */
   23          uint8 straight_entrance(void){
   24   1          ips200_clear();
   25   1          ips200_show_string(0,0,"Car is running straight");
   26   1          PID_control();
   27   1          return 0;
   28   1      }
   29          
   30          /**
   31           * @brief PID控制函数
   32           */
   33          void PID_control(void){
   34   1          int position;
   35   1          static int last_error = 0;
   36   1          static int integral = 0;
   37   1          int angle;
   38   1          while(1){
   39   2          position = Line_calculate_position();
   40   2          integral += position;
   41   2          angle = (position * Kp + integral * Ki + (position - last_error) * Kd) * reactFactor;
   42   2          last_error = position;
   43   2          servo_set_position(angle);
   44   2          drv8701_control(MOTOR_BOTH,0);
   45   2          if (integral > MAX_INTEGRAL)
   46   2              integral = MAX_INTEGRAL;
   47   2          if (integral < -MAX_INTEGRAL)
   48   2              integral = -MAX_INTEGRAL;
   49   2          if (last_error > MAX_DERIVATIVE)
   50   2              last_error = MAX_DERIVATIVE;
   51   2          if (last_error < -MAX_DERIVATIVE)
   52   2              last_error = -MAX_DERIVATIVE;
   53   2          delay_ms(10);
   54   2          }
   55   1      }
   56          
C251 COMPILER V5.60.0,  straight                                                           14/11/24  19:52:40  PAGE 2   

   57          /**
   58           * @brief 异常处理函数
   59           * @param exception_code 异常代码
   60           */
   61          void exception_handler(int exception_code)
   62          {
   63   1          ips200_clear();
   64   1          ips200_show_string(0,0,"Exception occured");
   65   1          switch(exception_code){
   66   2              case 999:
   67   2                  ips200_show_string(16,0,"System error");
   68   2                  break;
   69   2              case 998:
   70   2                  ips200_show_string(16,0,"Divide by zero");
   71   2                  break;
   72   2              case 997:
   73   2                  ips200_show_string(16,0,"Line lost");
   74   2                  break;
   75   2              case 996:
   76   2                  ips200_show_string(16,0,"Cross line");
   77   2                  return;
   78   2              case 995:
   79   2                  ips200_show_string(16,0,"Left roundabout");
   80   2                  break;
   81   2              case 994:
   82   2                  ips200_show_string(16,0,"Right roundabout");
   83   2                  break;
   84   2              default:
   85   2                  ips200_show_string(16,0,"Unknown error");
   86   2          }
   87   1      }
   88          
   89          /**
   90           * @brief 计算线的位置
   91           * 
   92           * 根据滤波后的ADC值计算线的位置。
   93           * 
   94           * @return int 线的位置，或错误代码
   95           * @warning 小心使用
   96           */
   97          int Line_calculate_position()
   98          {
   99   1          float adc1, adc2, adc3, adc4, denominator, position;
  100   1          char string_buffer[50];
  101   1          Line_read_raw();
  102   1          //归一化处理，范围是0-100
  103   1          adc1 = ((float)adc_value.ADC1 * 100) / 4095;
  104   1          adc2 = ((float)adc_value.ADC2 * 100) / 4095;
  105   1          adc3 = ((float)adc_value.ADC3 * 100) / 4095;
  106   1          adc4 = ((float)adc_value.ADC4 * 100) / 4095;
  107   1      
  108   1          denominator = adc1 + adc2 + adc3 + adc4;
  109   1      
  110   1          // //判断线的大致位置，使用两个传感器的值,adc1 和 adc4
  111   1          // if (adc1 > 1000 || adc4 > 1000)
  112   1          //     return 999; // 系统错误
  113   1          if (denominator == 0)
  114   1              return 0; // 除零错误
  115   1          if (denominator < 50)
  116   1              return 0; // 线丢失
  117   1          // if ((adc1 + adc4) < 100)
  118   1          //     return 997; // 线丢失
  119   1          // if (adc1 > 800 && adc2 > 800)
  120   1          //     return 996;                                 // 十字线
  121   1          // if ((adc1 - adc2) > 200)                        //左环岛处理
  122   1          // {
C251 COMPILER V5.60.0,  straight                                                           14/11/24  19:52:40  PAGE 3   

  123   1          //     delay_ms(100);
  124   1          //     if ((adc1 - adc2) > 250)
  125   1          //     {
  126   1          //         return 995;//左环岛
  127   1          //     }
  128   1          // }
  129   1          // if ((adc4 - adc3) > 200)                        //右环岛处理
  130   1          // {
  131   1          //     delay_ms(100);
  132   1          //     if ((adc4 - adc3) > 250)
  133   1          //     {
  134   1          //         return 994;//右环岛
  135   1          //     }
  136   1          // }
  137   1          // 使用差比和算法计算位置
  138   1          position = ((adc1 - adc4) + (adc2 - adc3)) * 1000.0 / denominator;
  139   1          //屏幕显示
  140   1          sprintf(string_buffer, "ADC1:%d    ", (int)adc1);
  141   1          ips200_show_string(0, 32, string_buffer);
  142   1          sprintf(string_buffer, "ADC2:%d    ", (int)adc2);
  143   1          ips200_show_string(0, 48, string_buffer);
  144   1          sprintf(string_buffer, "ADC3:%d    ", (int)adc3);
  145   1          ips200_show_string(0, 64, string_buffer);
  146   1          sprintf(string_buffer, "ADC4:%d    ", (int)adc4);
  147   1          ips200_show_string(0, 80, string_buffer);
  148   1          sprintf(string_buffer, "Denominator:%d    ", (int)denominator);
  149   1          ips200_show_string(0, 96, string_buffer);
  150   1          sprintf(string_buffer, "Position:%d    ", (int)position);
  151   1          ips200_show_string(0, 112, string_buffer);
  152   1          sprintf(string_buffer, "Oringinal adc1:%d    ", adc_value.ADC1);
  153   1          ips200_show_string(0, 128, string_buffer);
  154   1          sprintf(string_buffer, "Oringinal adc2:%d    ", adc_value.ADC2);
  155   1          ips200_show_string(0, 144, string_buffer);
  156   1          sprintf(string_buffer, "Oringinal adc3:%d    ", adc_value.ADC3);
  157   1          ips200_show_string(0, 160, string_buffer);
  158   1          sprintf(string_buffer, "Oringinal adc4:%d    ", adc_value.ADC4);
  159   1          ips200_show_string(0, 176, string_buffer);
  160   1          return (int)-position;
  161   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1106     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       108     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       369     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
