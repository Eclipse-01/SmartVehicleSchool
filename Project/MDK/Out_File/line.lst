C251 COMPILER V5.60.0,  line                                                               21/11/24  15:45:57  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE line
OBJECT MODULE PLACED IN .\Out_File\line.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE ..\CODE\UserLibraries\line.c XSMALL WARNINGLEVEL(3) OPTIMIZE(0,SPEED) 
                    -BROWSE INCDIR(..\..\Libraries\libraries;..\..\Libraries\seekfree_libraries;..\..\Libraries\seekfree_peripheral;..\CODE;.
                    -.\USER\inc;..\USER\src;..\..\Libraries\seekfree_components;..\CODE\UserLibraries;..\CODE\Algorithms) DEBUG PRINT(.\Out_F
                    -ile\line.lst) TABS(2) OBJECT(.\Out_File\line.obj) 

stmt  level    source

    1          #include "headfile.h"
    2          #include "line.h"
    3          
    4          ADC_Value adc_value; // 仅在此处定义
    5          
    6          // 返回的线的位置是根据adc1和adc4的值计算的
    7          
    8          #define FILTER_SIZE 5
    9          
   10          /**
   11           * @brief 初始化ADC通道
   12           *
   13           * 初始化与线传感器连接的ADC通道。
   14           */
   15          void Line_init()
   16          {
   17   1          adc_init(ADC_P06, 0); // P00引脚        具体通道与引脚对应关系可以查看zf_adc.h文件
   18   1          adc_init(ADC_P11, 0); // P01引脚        具体通道与引脚对应关系可以查看zf_adc.h文件
   19   1          adc_init(ADC_P14, 0); // P05引脚        具体通道与引脚对应关系可以查看zf_adc.h文件
   20   1          adc_init(ADC_P15, 0); // P06引脚        具体通道与引脚对应关系可以查看zf_adc.h文件
   21   1      }
   22          
   23          /**
   24           * @brief 读取原始ADC值并进行滤波处理
   25           *
   26           * 从ADC通道读取原始数据，并使用简单的滑动窗口滤波器对数据进行滤波。
   27           */
   28          void Line_read_raw()
   29          {
   30   1          int i;
   31   1          int filter_buffer1 = 0;
   32   1          int filter_buffer2 = 0;
   33   1          int filter_buffer3 = 0;
   34   1          int filter_buffer4 = 0;
   35   1          for (i = 0; i < FILTER_SIZE; i++) // 对数据进行滤波
   36   1          {
   37   2              filter_buffer1 += adc_once(ADC_P06, ADC_12BIT);
   38   2              filter_buffer2 += adc_once(ADC_P11, ADC_12BIT);
   39   2              filter_buffer3 += adc_once(ADC_P14, ADC_12BIT);
   40   2              filter_buffer4 += adc_once(ADC_P15, ADC_12BIT);
   41   2          }
   42   1          // 将滤波后的值存入结构体
   43   1          adc_value.ADC1 = filter_buffer1 / FILTER_SIZE;
   44   1          adc_value.ADC2 = filter_buffer2 / FILTER_SIZE;
   45   1          adc_value.ADC3 = filter_buffer3 / FILTER_SIZE;
   46   1          adc_value.ADC4 = filter_buffer4 / FILTER_SIZE;
   47   1      }
   48          
   49          // /**
   50          //  * @brief 计算线的位置
   51          //  *
   52          //  * 根据滤波后的ADC值计算线的位置。
   53          //  *
   54          //  * @return int 线的位置，或错误代码
   55          //  * @warning 小心使用
   56          //  */
C251 COMPILER V5.60.0,  line                                                               21/11/24  15:45:57  PAGE 2   

   57          // int Line_calculate_position()
   58          // {
   59          //     int adc1, adc2, adc3, adc4;
   60          //     int position;
   61          
   62          //     Line_read_raw();
   63          //     // 对 ADC 值进行归一化处理
   64          //     adc1 = (adc_value.ADC1 * 1000) / 4095;//范围是0-1000
   65          //     adc2 = (adc_value.ADC2 * 1000) / 4095;
   66          //     adc3 = (adc_value.ADC3 * 1000) / 4095;
   67          //     adc4 = (adc_value.ADC4 * 1000) / 4095;
   68          
   69          //     //判断线的大致位置，使用两个传感器的值,adc1 和 adc4
   70          //     if (adc1 > 1000 || adc4 > 1000)
   71          //         return 999; // 系统错误
   72          //     if ((adc1 + adc4) == 0)
   73          //         return 998; // 除零错误
   74          //     if ((adc1 + adc4) < 100U) // 将常量改为无符号类型
   75          //         return 997; // 线丢失
   76          //     if (adc1 > 800 && adc2 > 800)
   77          //         return 996;                                 // 十字线
   78          //     if ((adc1 - adc2) > 200)                        //左环岛处理
   79          //     {
   80          //         delay(100);
   81          //         if ((adc1 - adc2) > 250)
   82          //         {
   83          //             return 995;//左环岛
   84          //         }
   85          //     }
   86          //     if ((adc4 - adc3) > 200)                        //右环岛处理
   87          //     {
   88          //         delay(100);
   89          //         if ((adc4 - adc3) > 250)
   90          //         {
   91          //             return 994;//右环岛
   92          //         }
   93          //     }
   94          //     position = (adc1 - adc4) * 100 / (adc1 + adc4); // 差比和算法
   95          //     return position;
   96          // }
   97          
   98          /**
   99           * @brief 获取ADC值的范围
  100           *
  101           * 持续读取ADC值并显示每个通道的最小值和最大值。
  102           */
  103          void Get_ADC_Range()
  104          {
  105   1          // 删除未使用的变量 'i'
  106   1          // int i;
  107   1      
  108   1          // 将变量定义为无符号整数
  109   1          unsigned int min_adc1 = 4095, max_adc1 = 0;
  110   1          unsigned int min_adc2 = 4095, max_adc2 = 0;
  111   1          unsigned int min_adc3 = 4095, max_adc3 = 0;
  112   1          unsigned int min_adc4 = 4095, max_adc4 = 0;
  113   1          char buffer[30];
  114   1      
  115   1          while (1)
  116   1          {
  117   2              Line_read_raw();
  118   2              if (adc_value.ADC1 < min_adc1)
  119   2                  min_adc1 = adc_value.ADC1;
  120   2              if (adc_value.ADC1 > max_adc1)
  121   2                  max_adc1 = adc_value.ADC1;
  122   2              if (adc_value.ADC2 < min_adc2)
C251 COMPILER V5.60.0,  line                                                               21/11/24  15:45:57  PAGE 3   

  123   2                  min_adc2 = adc_value.ADC2;
  124   2              if (adc_value.ADC2 > max_adc2)
  125   2                  max_adc2 = adc_value.ADC2;
  126   2              if (adc_value.ADC3 < min_adc3)
  127   2                  min_adc3 = adc_value.ADC3;
  128   2              if (adc_value.ADC3 > max_adc3)
  129   2                  max_adc3 = adc_value.ADC3;
  130   2              if (adc_value.ADC4 < min_adc4)
  131   2                  min_adc4 = adc_value.ADC4;
  132   2              if (adc_value.ADC4 > max_adc4)
  133   2                  max_adc4 = adc_value.ADC4;
  134   2      
  135   2              // 在IPS200显示屏上显示最小值和最大值
  136   2              sprintf(buffer, "Min ADC1: %d    ", min_adc1);
  137   2              ips200_show_string(0, 0, buffer);
  138   2              sprintf(buffer, "Max ADC1: %d    ", max_adc1);
  139   2              ips200_show_string(0, 20, buffer);
  140   2              sprintf(buffer, "Min ADC2: %d    ", min_adc2);
  141   2              ips200_show_string(0, 40, buffer);
  142   2              sprintf(buffer, "Max ADC2: %d    ", max_adc2);
  143   2              ips200_show_string(0, 60, buffer);
  144   2              sprintf(buffer, "Min ADC3: %d    ", min_adc3);
  145   2              ips200_show_string(0, 80, buffer);
  146   2              sprintf(buffer, "Max ADC3: %d    ", max_adc3);
  147   2              ips200_show_string(0, 100, buffer);
  148   2              sprintf(buffer, "Min ADC4: %d    ", min_adc4);
  149   2              ips200_show_string(0, 120, buffer);
  150   2              sprintf(buffer, "Max ADC4: %d    ", max_adc4);
  151   2              ips200_show_string(0, 140, buffer);
  152   2              // 显示当前值
  153   2              sprintf(buffer, "ADC1: %d    ", adc_once(ADC_P06, ADC_12BIT));
  154   2              ips200_show_string(0, 160, buffer);
  155   2              sprintf(buffer, "ADC2: %d    ", adc_once(ADC_P11, ADC_12BIT));
  156   2              ips200_show_string(0, 180, buffer);
  157   2              sprintf(buffer, "ADC3: %d    ", adc_once(ADC_P14, ADC_12BIT));
  158   2              ips200_show_string(0, 200, buffer);
  159   2              sprintf(buffer, "ADC4: %d    ", adc_once(ADC_P15, ADC_12BIT));
  160   2              ips200_show_string(0, 220, buffer);
  161   2          }
  162   1      }
  163          
  164          void Remote_Stop()
  165          {
  166   1          char str[256];
  167   1          char command;
  168   1          if (wireless_uart_read_buff(str, 99) != 0)
  169   1          {
  170   2              drv8701_stop(MOTOR_BOTH);
  171   2              str[0] = "Recieved stop signal, motor stopped\n Activating remote control\n";
*** WARNING C161 IN LINE 171 OF ..\CODE\UserLibraries\line.c: 'huge const' pointer truncated to 'char'
*** WARNING C10 IN LINE 171 OF ..\CODE\UserLibraries\line.c: conversion: 'pointer' to 'char'
  172   2              wireless_uart_send_buff(str, strlen(str));
  173   2              memset(str, 0, sizeof(str));
  174   2              str[0] = "Activating RC\n";
*** WARNING C161 IN LINE 174 OF ..\CODE\UserLibraries\line.c: 'huge const' pointer truncated to 'char'
*** WARNING C10 IN LINE 174 OF ..\CODE\UserLibraries\line.c: conversion: 'pointer' to 'char'
  175   2              wireless_uart_send_buff(str, strlen(str));
  176   2              while (1)
  177   2              {
  178   3                  if (wireless_uart_read_buff(command, 1) != 0)
*** WARNING C40 IN LINE 178 OF ..\CODE\UserLibraries\line.c: 'char' converted to 'far' pointer
  179   3                  {
  180   4                      // 大小写处理
  181   4                      if (command >= 'A' && command <= 'Z')
  182   4                      {
  183   5                          command += 32;
C251 COMPILER V5.60.0,  line                                                               21/11/24  15:45:57  PAGE 4   

  184   5                      }
  185   4                      wireless_uart_send_byte(command);
  186   4                      delay_ms(10000);
  187   4                      switch (command)
  188   4                      {
  189   5                      case 'w':
  190   5                          drv8701_control(MOTOR_BOTH, 35);
  191   5                          delay_ms(100);
  192   5                          drv8701_stop(MOTOR_BOTH);
  193   5                          break;
  194   5                      case 's':
  195   5                          drv8701_control(MOTOR_BOTH, -35);
  196   5                          delay_ms(100);
  197   5                          drv8701_stop(MOTOR_BOTH);
  198   5                          break;
  199   5                      case 'a':
  200   5                          drv8701_control(MOTOR_R, 35);
  201   5                          delay_ms(100);
  202   5                          drv8701_stop(MOTOR_BOTH);
  203   5                          break;
  204   5                      case 'd':
  205   5                          drv8701_control(MOTOR_L, 35);
  206   5                          delay_ms(100);
  207   5                          drv8701_stop(MOTOR_BOTH);
  208   5                          break;
  209   5                      case 'r':
  210   5                          code_entrance();
  211   5                          break;
  212   5      
  213   5                      default:
  214   5                          drv8701_stop(MOTOR_BOTH);
  215   5                          str[0] = "Invalid command, motor stopped\n";
*** WARNING C161 IN LINE 215 OF ..\CODE\UserLibraries\line.c: 'huge const' pointer truncated to 'char'
*** WARNING C10 IN LINE 215 OF ..\CODE\UserLibraries\line.c: conversion: 'pointer' to 'char'
  216   5                          wireless_uart_send_buff(str, strlen(str));
  217   5                          break;
  218   5                      
  219   5                      delay_ms(10);
  220   5                      }
  221   4                  }
  222   3              }
  223   2          }
  224   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1266     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       321     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       299     ------
End of Module Information.


C251 COMPILATION COMPLETE.  7 WARNING(S),  0 ERROR(S)
